#ifndef _NAlib_h
#define _NAlib_h

#include<stdio.h>
#include<math.h>
#include<string.h>
#include<stdlib.h>
#include<iostream>
#include<malloc.h>


#define ZERO 1e-14
#define TRUE 1
#define FALSE 0
#define MaxRowNumber 1000
#define MaxColumnNumber 1000

template<class T>
T ABS(T temp) {
	return temp > 0 ? temp : -temp;
}

// 表达式解析函数 
double eval(char s[], double x); 

// 从字符串中读取数字 
double ReadNumber(char s[], int* Length);

// 运算数判断 
int JudgeOperand(char c, int* prior);

// 读取运算符 
char GetOperator(char stack[], int i);
double GetOperand(double stack[], int i);
double Compute(char symbol, double num1, double num2);

//求函数某一点导数的函数 
double Differential(char Expression[], double x); 
//求函数在一个区间积分的函数 
double Integral(char Expression[], double start, double end);
//利用二分法求函数的零点 
double Bisection(char Expression[], double a, double b, double eps, int N);
//利用不动点法求函数的零点
 double FixedPoint(char Expression[], double x, double eps, int N); 
//利用牛顿法求函数的零点
double Newton(char Expression[], double x, double eps, int N); 
//利用割线法求函数的零点 
double Secant(char Expression[], double p0, double p1, double eps, int N);
//利用加速迭代求函数的不动点 
double Steffensen(char Expression[], double p0, double eps, int N); 
//矩阵高斯消元 
int GaussElimination(double** mat, int row, int column); 
//高斯若当方法
int GaussJordanMethod(double** a, int row, int column);
//反向求解
int BackwardSubstitutionProcess(double** a, double* b,int n);

//判断一个数是否为零
bool IsZero(double a);
//判断一个数是否为一
bool IsOne(double a);
//多项式转化的辅助函数
int PolynomialConvertAuxiliary(double x[], bool vis[], int total, double* res, int n, int current, int guard);


#endif
